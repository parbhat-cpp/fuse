// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: subscription_usage.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSubscriptionUsage = `-- name: CreateSubscriptionUsage :one
INSERT INTO subscription_usage (user_id, valid_from, valid_until, usage)
VALUES ($1, $2, $3, $4)
RETURNING (id, subscription_id, valid_from, valid_until)
`

type CreateSubscriptionUsageParams struct {
	UserID     pgtype.UUID
	ValidFrom  pgtype.Timestamptz
	ValidUntil pgtype.Timestamptz
	Usage      []byte
}

func (q *Queries) CreateSubscriptionUsage(ctx context.Context, arg CreateSubscriptionUsageParams) (interface{}, error) {
	row := q.db.QueryRow(ctx, createSubscriptionUsage,
		arg.UserID,
		arg.ValidFrom,
		arg.ValidUntil,
		arg.Usage,
	)
	var column_1 interface{}
	err := row.Scan(&column_1)
	return column_1, err
}

const getAllSubscriptionUsage = `-- name: GetAllSubscriptionUsage :many
SELECT id, subscription_id, valid_from, valid_until, usage
FROM subscription_usage WHERE user_id = $1
`

type GetAllSubscriptionUsageRow struct {
	ID             pgtype.UUID
	SubscriptionID pgtype.UUID
	ValidFrom      pgtype.Timestamptz
	ValidUntil     pgtype.Timestamptz
	Usage          []byte
}

func (q *Queries) GetAllSubscriptionUsage(ctx context.Context, userID pgtype.UUID) ([]GetAllSubscriptionUsageRow, error) {
	rows, err := q.db.Query(ctx, getAllSubscriptionUsage, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllSubscriptionUsageRow
	for rows.Next() {
		var i GetAllSubscriptionUsageRow
		if err := rows.Scan(
			&i.ID,
			&i.SubscriptionID,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.Usage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscriptionUsageByID = `-- name: GetSubscriptionUsageByID :one
SELECT id, subscription_id, valid_from, valid_until, usage
FROM subscription_usage WHERE user_id = $1 ORDER BY created_at DESC LIMIT 1
`

type GetSubscriptionUsageByIDRow struct {
	ID             pgtype.UUID
	SubscriptionID pgtype.UUID
	ValidFrom      pgtype.Timestamptz
	ValidUntil     pgtype.Timestamptz
	Usage          []byte
}

func (q *Queries) GetSubscriptionUsageByID(ctx context.Context, userID pgtype.UUID) (GetSubscriptionUsageByIDRow, error) {
	row := q.db.QueryRow(ctx, getSubscriptionUsageByID, userID)
	var i GetSubscriptionUsageByIDRow
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.Usage,
	)
	return i, err
}

const updateSubscriptionUsage = `-- name: UpdateSubscriptionUsage :one
UPDATE subscription_usage SET usage = $3
WHERE subscription_id = $1 AND user_id = $2
RETURNING (id, subscription_id, valid_from, valid_until, usage)
`

type UpdateSubscriptionUsageParams struct {
	SubscriptionID pgtype.UUID
	UserID         pgtype.UUID
	Usage          []byte
}

func (q *Queries) UpdateSubscriptionUsage(ctx context.Context, arg UpdateSubscriptionUsageParams) (interface{}, error) {
	row := q.db.QueryRow(ctx, updateSubscriptionUsage, arg.SubscriptionID, arg.UserID, arg.Usage)
	var column_1 interface{}
	err := row.Scan(&column_1)
	return column_1, err
}

const updateSubscriptionUsageDuration = `-- name: UpdateSubscriptionUsageDuration :one
UPDATE subscription_usage SET valid_from = $3, valid_until = $4
WHERE subscription_id = $1 AND user_id = $2
RETURNING (id, subscription_id, valid_from, valid_until, usage)
`

type UpdateSubscriptionUsageDurationParams struct {
	SubscriptionID pgtype.UUID
	UserID         pgtype.UUID
	ValidFrom      pgtype.Timestamptz
	ValidUntil     pgtype.Timestamptz
}

func (q *Queries) UpdateSubscriptionUsageDuration(ctx context.Context, arg UpdateSubscriptionUsageDurationParams) (interface{}, error) {
	row := q.db.QueryRow(ctx, updateSubscriptionUsageDuration,
		arg.SubscriptionID,
		arg.UserID,
		arg.ValidFrom,
		arg.ValidUntil,
	)
	var column_1 interface{}
	err := row.Scan(&column_1)
	return column_1, err
}
