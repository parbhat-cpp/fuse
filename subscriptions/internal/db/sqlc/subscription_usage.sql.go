// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: subscription_usage.sql

package sqlc

import (
	"context"
	"encoding/json"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSubscriptionUsage = `-- name: CreateSubscriptionUsage :one
INSERT INTO subscription_usage (user_id, valid_from, valid_until, usage, subscription_id)
VALUES ($1, $2, $3, $4::text::jsonb, $5)
RETURNING id, subscription_id, valid_from, valid_until, usage, subscription_id
`

type CreateSubscriptionUsageParams struct {
	UserID         pgtype.UUID
	ValidFrom      pgtype.Timestamptz
	ValidUntil     pgtype.Timestamptz
	Column4        string
	SubscriptionID pgtype.UUID
}

type CreateSubscriptionUsageRow struct {
	ID               pgtype.UUID
	SubscriptionID   pgtype.UUID
	ValidFrom        pgtype.Timestamptz
	ValidUntil       pgtype.Timestamptz
	Usage            json.RawMessage
	SubscriptionID_2 pgtype.UUID
}

func (q *Queries) CreateSubscriptionUsage(ctx context.Context, arg CreateSubscriptionUsageParams) (CreateSubscriptionUsageRow, error) {
	row := q.db.QueryRow(ctx, createSubscriptionUsage,
		arg.UserID,
		arg.ValidFrom,
		arg.ValidUntil,
		arg.Column4,
		arg.SubscriptionID,
	)
	var i CreateSubscriptionUsageRow
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.Usage,
		&i.SubscriptionID_2,
	)
	return i, err
}

const getAllSubscriptionUsage = `-- name: GetAllSubscriptionUsage :many
SELECT id, subscription_id, valid_from, valid_until, usage
FROM subscription_usage WHERE user_id = $1 ORDER BY created_at DESC
`

type GetAllSubscriptionUsageRow struct {
	ID             pgtype.UUID
	SubscriptionID pgtype.UUID
	ValidFrom      pgtype.Timestamptz
	ValidUntil     pgtype.Timestamptz
	Usage          json.RawMessage
}

func (q *Queries) GetAllSubscriptionUsage(ctx context.Context, userID pgtype.UUID) ([]GetAllSubscriptionUsageRow, error) {
	rows, err := q.db.Query(ctx, getAllSubscriptionUsage, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllSubscriptionUsageRow
	for rows.Next() {
		var i GetAllSubscriptionUsageRow
		if err := rows.Scan(
			&i.ID,
			&i.SubscriptionID,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.Usage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSubscriptionUsageWithSubscription = `-- name: GetAllSubscriptionUsageWithSubscription :many
SELECT su.id, su.valid_from, su.valid_until, su.usage, s.id AS subscription_id, s.plan_type
FROM subscription_usage AS su
LEFT JOIN subscriptions AS s ON s.id = su.subscription_id 
WHERE su.user_id = $1 ORDER BY su.created_at DESC
`

type GetAllSubscriptionUsageWithSubscriptionRow struct {
	ID             pgtype.UUID
	ValidFrom      pgtype.Timestamptz
	ValidUntil     pgtype.Timestamptz
	Usage          json.RawMessage
	SubscriptionID pgtype.UUID
	PlanType       pgtype.Text
}

func (q *Queries) GetAllSubscriptionUsageWithSubscription(ctx context.Context, userID pgtype.UUID) ([]GetAllSubscriptionUsageWithSubscriptionRow, error) {
	rows, err := q.db.Query(ctx, getAllSubscriptionUsageWithSubscription, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllSubscriptionUsageWithSubscriptionRow
	for rows.Next() {
		var i GetAllSubscriptionUsageWithSubscriptionRow
		if err := rows.Scan(
			&i.ID,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.Usage,
			&i.SubscriptionID,
			&i.PlanType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrentSubscriptionUsageByUserID = `-- name: GetCurrentSubscriptionUsageByUserID :one
SELECT id, subscription_id, valid_from, valid_until, usage
FROM subscription_usage WHERE user_id = $1 AND valid_from <= NOW() AND valid_until >= NOW() ORDER BY created_at DESC LIMIT 1
`

type GetCurrentSubscriptionUsageByUserIDRow struct {
	ID             pgtype.UUID
	SubscriptionID pgtype.UUID
	ValidFrom      pgtype.Timestamptz
	ValidUntil     pgtype.Timestamptz
	Usage          json.RawMessage
}

func (q *Queries) GetCurrentSubscriptionUsageByUserID(ctx context.Context, userID pgtype.UUID) (GetCurrentSubscriptionUsageByUserIDRow, error) {
	row := q.db.QueryRow(ctx, getCurrentSubscriptionUsageByUserID, userID)
	var i GetCurrentSubscriptionUsageByUserIDRow
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.Usage,
	)
	return i, err
}

const getCurrentSubscriptionUsageWithSubscriptionByUserID = `-- name: GetCurrentSubscriptionUsageWithSubscriptionByUserID :one
SELECT su.id, su.valid_from, su.valid_until, su.usage, s.id AS subscription_id, s.plan_type
FROM subscription_usage AS su
INNER JOIN subscriptions AS s ON s.id = su.subscription_id 
WHERE su.user_id = $1 AND su.valid_from <= NOW() AND su.valid_until >= NOW() ORDER BY su.created_at DESC LIMIT 1
`

type GetCurrentSubscriptionUsageWithSubscriptionByUserIDRow struct {
	ID             pgtype.UUID
	ValidFrom      pgtype.Timestamptz
	ValidUntil     pgtype.Timestamptz
	Usage          json.RawMessage
	SubscriptionID pgtype.UUID
	PlanType       string
}

func (q *Queries) GetCurrentSubscriptionUsageWithSubscriptionByUserID(ctx context.Context, userID pgtype.UUID) (GetCurrentSubscriptionUsageWithSubscriptionByUserIDRow, error) {
	row := q.db.QueryRow(ctx, getCurrentSubscriptionUsageWithSubscriptionByUserID, userID)
	var i GetCurrentSubscriptionUsageWithSubscriptionByUserIDRow
	err := row.Scan(
		&i.ID,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.Usage,
		&i.SubscriptionID,
		&i.PlanType,
	)
	return i, err
}

const getSubscriptionUsageByID = `-- name: GetSubscriptionUsageByID :one
SELECT id, subscription_id, valid_from, valid_until, usage
FROM subscription_usage WHERE user_id = $1 ORDER BY created_at DESC LIMIT 1
`

type GetSubscriptionUsageByIDRow struct {
	ID             pgtype.UUID
	SubscriptionID pgtype.UUID
	ValidFrom      pgtype.Timestamptz
	ValidUntil     pgtype.Timestamptz
	Usage          json.RawMessage
}

func (q *Queries) GetSubscriptionUsageByID(ctx context.Context, userID pgtype.UUID) (GetSubscriptionUsageByIDRow, error) {
	row := q.db.QueryRow(ctx, getSubscriptionUsageByID, userID)
	var i GetSubscriptionUsageByIDRow
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.Usage,
	)
	return i, err
}

const updateSubscriptionUsage = `-- name: UpdateSubscriptionUsage :one
UPDATE subscription_usage SET usage = $3::text::jsonb
WHERE id = $1 AND user_id = $2
RETURNING id, subscription_id, valid_from, valid_until, usage
`

type UpdateSubscriptionUsageParams struct {
	ID      pgtype.UUID
	UserID  pgtype.UUID
	Column3 string
}

type UpdateSubscriptionUsageRow struct {
	ID             pgtype.UUID
	SubscriptionID pgtype.UUID
	ValidFrom      pgtype.Timestamptz
	ValidUntil     pgtype.Timestamptz
	Usage          json.RawMessage
}

func (q *Queries) UpdateSubscriptionUsage(ctx context.Context, arg UpdateSubscriptionUsageParams) (UpdateSubscriptionUsageRow, error) {
	row := q.db.QueryRow(ctx, updateSubscriptionUsage, arg.ID, arg.UserID, arg.Column3)
	var i UpdateSubscriptionUsageRow
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.Usage,
	)
	return i, err
}

const updateSubscriptionUsageDuration = `-- name: UpdateSubscriptionUsageDuration :one
UPDATE subscription_usage SET valid_from = $3, valid_until = $4
WHERE subscription_id = $1 AND user_id = $2
RETURNING id, subscription_id, valid_from, valid_until, usage
`

type UpdateSubscriptionUsageDurationParams struct {
	SubscriptionID pgtype.UUID
	UserID         pgtype.UUID
	ValidFrom      pgtype.Timestamptz
	ValidUntil     pgtype.Timestamptz
}

type UpdateSubscriptionUsageDurationRow struct {
	ID             pgtype.UUID
	SubscriptionID pgtype.UUID
	ValidFrom      pgtype.Timestamptz
	ValidUntil     pgtype.Timestamptz
	Usage          json.RawMessage
}

func (q *Queries) UpdateSubscriptionUsageDuration(ctx context.Context, arg UpdateSubscriptionUsageDurationParams) (UpdateSubscriptionUsageDurationRow, error) {
	row := q.db.QueryRow(ctx, updateSubscriptionUsageDuration,
		arg.SubscriptionID,
		arg.UserID,
		arg.ValidFrom,
		arg.ValidUntil,
	)
	var i UpdateSubscriptionUsageDurationRow
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.Usage,
	)
	return i, err
}
